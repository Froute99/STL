

파일이름: source.cpp
파일크기: 358
2022-03-23 17:49:17 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sor를 통해 알아본다
 * 
 */

#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

int main() {
	std::ifstream in{ "source.cpp" };
	char c;

	in >> std::noskipws;
	while (in >> c) {
		std::cout << c;
	}

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 427
2022-03-23 17:52:47 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sor를 통해 알아본다
 * 
 */

#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

int main() {
	std::ifstream in{ "source.cpp" };
	char c;

	in >> std::noskipws;
	while (in >> c) {
		if (islower(c)) {
			c = toupper(c);
			// ch to uppercase
		}
		std::cout << c;
	}

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 418
2022-03-23 17:54:40 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sor를 통해 알아본다
 * 
 */

#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

int main() {
	std::ifstream in{ "source.cpp" };
	std::ofstream out{ "source_capital.cpp" };

	char c;

	in >> std::noskipws;
	while (in >> c) {
		c = toupper(c);
		out << c;
	}

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 498
2022-03-23 18:09:08 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sor를 통해 알아본다
 * 
 */

#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

int main() {
	std::ifstream in{ "source.cpp" };
	std::ofstream out{ "source_capital.cpp" };

	std::transform(std::istreambuf_iterator<char>{in}, std::istreambuf_iterator<char>{in}, std::ostreambuf_iterator<char>{std::cout},
		[](char c) { return toupper(c); });

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 498
2022-03-23 18:09:28 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sor를 통해 알아본다
 * 
 */

#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

int main() {
	std::ifstream in{ "source.cpp" };
	std::ofstream out{ "source_capital.cpp" };

	std::transform(std::istreambuf_iterator<char>{in}, std::istreambuf_iterator<char>{in}, std::ostreambuf_iterator<char>{std::cout},
		[](char c) { return toupper(c); });

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 466
2022-03-23 18:10:18 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sor를 통해 알아본다
 * 
 */

#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

int main() {
	std::ifstream in{ "source.cpp" };
	std::ofstream out{ "source_capital.cpp" };

	std::transform(std::istreambuf_iterator<char>{in}, {}, std::ostreambuf_iterator<char>{std::cout},
		[](char c) { return toupper(c); });

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 573
2022-03-23 18:15:50 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sor를 통해 알아본다
 * 
 */

#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

// 문제: "source.cpp"를 읽어서
// 숫자를 *로 바꿔
// 화면에 출력하라

int main() {
	std::ifstream in{ "source.cpp" };
	std::ofstream out{ "source_capital.cpp" };

	std::transform(std::istreambuf_iterator<char>{in}, {}, std::ostreambuf_iterator<char>{std::cout},
		[](char c) {
			if (isdigit(c)) { std::cout << '*'; } return c; });

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 564
2022-03-23 18:16:07 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sor를 통해 알아본다
 * 
 */

#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

// 문제: "source.cpp"를 읽어서
// 숫자를 *로 바꿔
// 화면에 출력하라

int main() {
	std::ifstream in{ "source.cpp" };
	std::ofstream out{ "source_capital.cpp" };

	std::transform(std::istreambuf_iterator<char>{in}, {}, std::ostreambuf_iterator<char>{std::cout},
		[](char c) {
			if (isdigit(c)) { c = '*'; } return c; });

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 709
2022-03-23 18:36:00 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include <array>
#include <algorithm>
#include <random>
#include "save.h"

// 문제: 랜덤 int 100개를 생성
// 오름차순으로 정렬
// 정렬된 결과를 출력

std::random_device rd;
std::default_random_engine dre(rd());


int main() {
	std::uniform_int_distribution<int> uid(std::numeric_limits<int>::min(), std::numeric_limits<int>::max());
	
	std::array<int, 100> numbers;
	numbers.fill(uid(dre));
	
	for (int n : numbers) {
		std::cout << n << '\t';
	}



	save("source.cpp");
}



파일이름: source.cpp
파일크기: 745
2022-03-23 18:40:18 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include <array>
#include <format>
#include <algorithm>
#include <random>
#include "save.h"

// 문제: 랜덤 int 100개를 생성
// 오름차순으로 정렬
// 정렬된 결과를 출력

std::random_device rd;
std::default_random_engine dre(rd());


int main() {
	std::uniform_int_distribution<int> uid(std::numeric_limits<int>::min(), std::numeric_limits<int>::max());
	
	std::array<int, 100> numbers;
	
	for (int& number : numbers) {
		number = uid(dre);
		std::cout << std::format("{:20}", number);
	}

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 744
2022-03-23 18:40:56 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include <array>
#include <format>
#include <algorithm>
#include <random>
#include "save.h"

// 문제: 랜덤 int 100개를 생성
// 오름차순으로 정렬
// 정렬된 결과를 출력

std::random_device rd;
std::default_random_engine dre(rd());


int main() {
	std::uniform_int_distribution<int> uid(std::numeric_limits<int>::min(), std::numeric_limits<int>::max());
	
	std::array<int, 100> numbers;
	
	for (int& number : numbers) {
		number = uid(dre);
		std::cout << std::format("{:5}", number);
	}

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 829
2022-03-23 18:42:04 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include <array>
#include <format>
#include <algorithm>
#include <random>
#include "save.h"

// 문제: 랜덤 int 100개를 생성
// 오름차순으로 정렬
// 정렬된 결과를 출력

std::random_device rd;
std::default_random_engine dre(rd());


int main() {
	std::uniform_int_distribution<int> uid(std::numeric_limits<int>::min(), std::numeric_limits<int>::max());
	
	std::array<int, 100> numbers;
	
	for (int& number : numbers) {
		number = uid(dre);
	}

	std::sort(numbers.begin(), numbers.end());

	for (int number : numbers) {
		std::cout << std::format("{:20}", number);
	}

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 829
2022-03-23 18:42:15 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include <array>
#include <format>
#include <algorithm>
#include <random>
#include "save.h"

// 문제: 랜덤 int 100개를 생성
// 오름차순으로 정렬
// 정렬된 결과를 출력

std::random_device rd;
std::default_random_engine dre(rd());


int main() {
	std::uniform_int_distribution<int> uid(std::numeric_limits<int>::min(), std::numeric_limits<int>::max());
	
	std::array<int, 100> numbers;
	
	for (int& number : numbers) {
		number = uid(dre);
	}

	std::sort(numbers.begin(), numbers.end());

	for (int number : numbers) {
		std::cout << std::format("{:20}", number);
	}

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 778
2022-03-23 18:44:40 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include <array>
#include <format>
#include <algorithm>
#include <random>
#include "save.h"

// 문제: [1, 100] 정수를 생성
// 오름차순으로 정렬
// 정렬된 결과를 출력

std::random_device rd;
std::default_random_engine dre(rd());
std::uniform_int_distribution<int> uid(1, 100);


int main() {
	
	std::array<int, 100> numbers;
	
	for (int& number : numbers) {
		number = uid(dre) % 100 + 1;
	}

	std::sort(numbers.begin(), numbers.end());

	for (int number : numbers) {
		std::cout << std::format("{:4}", number);
	}

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 825
2022-03-23 19:01:12 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include <array>
#include <format>
#include <algorithm>
#include <random>
#include "save.h"

// 문제: [1, 100] 정수를 생성
// 오름차순으로 정렬
// 정렬된 결과를 출력

std::random_device rd;
std::default_random_engine dre(rd());
std::uniform_int_distribution<int> uid(1, 100);


int main() {
	
	std::array<int, 100> numbers;
	
	for (int& number : numbers) {
		number = uid(dre) % 100 + 1;
	}

	std::sort(numbers.begin(), numbers.end(), 
		[](int a, int b) {
			return a > b;
		});

	for (int number : numbers) {
		std::cout << std::format("{:4}", number);
	}

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 844
2022-03-23 19:05:30 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include <array>
#include <format>
#include <algorithm>
#include <random>
#include "save.h"

// 문제: [1, 100] 정수를 생성
// 오름차순으로 정렬
// 정렬된 결과를 출력

std::random_device rd;
std::default_random_engine dre(rd());
std::uniform_int_distribution<int> uid(1, 100);

bool Descending(int a, int b) {
	return a > b;
}


int main() {
	
	std::array<int, 100> numbers;
	
	for (int& number : numbers) {
		number = uid(dre) % 100 + 1;
	}

	std::sort(numbers.begin(), numbers.end(), Descending);

	for (int number : numbers) {
		std::cout << std::format("{:4}", number);
	}

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 494
2022-03-23 19:06:45 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);


// 메모리 마지막 동네 소개
//
//

void f() {
	std::cout << "f" << std::endl;
}

int main() {
	f();
	*f;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 487
2022-03-23 19:06:54 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);


// 메모리 마지막 동네 소개
//
//

void f() {
	std::cout << "f" << std::endl;
}

int main() {
	*f;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 487
2022-03-23 19:07:05 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);


// 메모리 마지막 동네 소개
//
//

void f() {
	std::cout << "f" << std::endl;
}

int main() {
	&f;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 512
2022-03-23 19:08:26 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);


// 메모리 마지막 동네 소개
//
//

void f() {
	std::cout << "f" << std::endl;
}

int main() {
	void(*const ptr)(f);

	*f;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 512
2022-03-23 19:08:42 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);


// 메모리 마지막 동네 소개
//
//

void f() {
	std::cout << "f" << std::endl;
}

int main() {
	void(*const ptr)(f);

	&f;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 516
2022-03-23 19:08:59 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);


// 메모리 마지막 동네 소개
//
//

void f() {
	std::cout << "f" << std::endl;
}

int main() {
	void(*const ptr)() = f;

	ptr;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 517
2022-03-23 19:09:03 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);


// 메모리 마지막 동네 소개
//
//

void f() {
	std::cout << "f" << std::endl;
}

int main() {
	void(*const ptr)() = f;

	*ptr;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 525
2022-03-23 19:10:21 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);


// 메모리 마지막 동네 소개
//
//

void f() {
	std::cout << "f" << std::endl;
}

int main() {
	void(*const ptr)(void) = f;

	(*ptr)();

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 674
2022-03-23 19:14:39 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);


// 메모리 마지막 동네 소개
//
//

void f() {
	std::cout << "f" << std::endl;
}

int main() {
	void(*const ptr)(void) = f;

	(*ptr)();

	std::cout << std::addressof(f) << std::endl;
	std::cout << std::addressof(main) << std::endl;
	std::cout << std::addressof(save) << std::endl;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 687
2022-03-24 13:36:37 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);

// 메모리 마지막 동네 소개


void foo() {
	std::cout << "foo" << std::endl;
}

int main() {
	// 함수이름이란? - 명령어들의 집합인 함수가 기록되어 있는 CODE 세그먼트의
	// 시작번지이다
	// 함수의 이름의 자료형(data type)은 무엇입니까?

	auto x = main;
	std::cout << typeid(x).name() << std::endl;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 705
2022-03-24 13:39:18 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);

// 메모리 마지막 동네 소개


void foo() {
	std::cout << "foo" << std::endl;
}

int main() {
	// 함수이름이란? - 명령어들의 집합인 함수가 기록되어 있는 CODE 세그먼트의
	// 시작번지이다
	// 함수의 이름의 자료형(data type)은 무엇입니까?

	//auto x = main;

	int x[100];
	std::cout << typeid(x).name() << std::endl;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 689
2022-03-24 13:39:43 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);

// 메모리 마지막 동네 소개


void foo() {
	std::cout << "foo" << std::endl;
}

int main() {
	// 함수이름이란? - 명령어들의 집합인 함수가 기록되어 있는 CODE 세그먼트의
	// 시작번지이다
	// 함수의 이름의 자료형(data type)은 무엇입니까?

	auto x = main;
	std::cout << typeid(foo).name() << std::endl;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 831
2022-03-24 13:57:24 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include <thread>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);

void foo() {
	std::cout << "foo" << std::endl;
}

void bar() {
	std::cout << "bar" << std::endl;
}


int main() {
	save("source.cpp");

	void(*p)(void) = foo;

	int count{};
	while (true) {
		p();
		using namespace std::literals;
		std::this_thread::sleep_for(1s);

		// toggle every 3 seconds
		if ((++count % 3) == 0) {
			if (p == foo) {
				p = bar;
			}
			else {
				p = foo;
			}
		}
	}

}



파일이름: source.cpp
파일크기: 804
2022-03-24 14:02:43 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include <thread>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);

void foo() {
	std::cout << "foo" << std::endl;
}

int g;

int main() {
	save("source.cpp");

	void(*p)(void) = foo;

	int count{};

	int* f = new int;

	std::cout << "CODE - ";
	std::cout << "DATA - ";
	std::cout << "STACK - f" << std::addressof(f) << std::endl;
	std::cout << "STACK - p" << std::addressof(p) << std::endl;
	std::cout << "Free Store - " << std::addressof(*f);

}



파일이름: source.cpp
파일크기: 1159
2022-03-24 14:06:29 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include <thread>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);

void foo() {
	std::cout << "foo" << std::endl;
}

int g;

int main() {
	save("source.cpp");

	void(*p)(void) = foo;

	int count{};

	int* f = new int;

	std::cout << "CODE		 - foo    " << std::addressof(foo) << std::endl;
	std::cout << "CODE		 - main   " << std::addressof(main) << std::endl;
	std::cout << "CODE		 - save   " << std::addressof(save) << std::endl;
	std::cout << "CODE		 - pfoo   " << std::endl;
	std::cout << std::endl;
	std::cout << "DATA		 - g   " << std::endl;
	std::cout << std::endl;
	std::cout << "STACK		 - f	" << std::addressof(f) << std::endl;
	std::cout << "STACK		 - p " << std::addressof(p) << std::endl;
	std::cout << std::endl;
	std::cout << "Free Store - *f" << std::addressof(*f) << std::endl;

}



파일이름: source.cpp
파일크기: 1180
2022-03-24 14:07:06 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include <thread>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);

void foo() {
	std::cout << "foo" << std::endl;
}

int g;

int main() {
	save("source.cpp");

	void(*p)(void) = foo;

	int count{};

	int* f = new int;

	std::cout << "CODE		 - foo    " << std::addressof(foo) << std::endl;
	std::cout << "CODE		 - main   " << std::addressof(main) << std::endl;
	std::cout << "CODE		 - save   " << std::addressof(save) << std::endl;
	std::cout << "CODE		 - pfoo   " << std::endl;
	std::cout << std::endl;
	std::cout << "DATA		 - g   " << std::addressof(g) << std::endl;
	std::cout << std::endl;
	std::cout << "STACK		 - f	" << std::addressof(f) << std::endl;
	std::cout << "STACK		 - p " << std::addressof(p) << std::endl;
	std::cout << std::endl;
	std::cout << "Free Store - *f" << std::addressof(*f) << std::endl;

}



파일이름: source.cpp
파일크기: 1198
2022-03-24 14:08:14 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include <thread>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);

void foo() {
	std::cout << "foo" << std::endl;
}

int g;

int main() {
	save("source.cpp");

	void(*p)(void) = foo;

	int count{};

	int* f = new int;

	std::cout << "CODE		 - foo		" << std::addressof(foo) << std::endl;
	std::cout << "CODE		 - main		" << std::addressof(main) << std::endl;
	std::cout << "CODE		 - save		" << std::addressof(save) << std::endl;
	std::cout << "CODE		 - *p		" << std::addressof(*p) << std::endl;
	std::cout << std::endl;
	std::cout << "DATA		 - g		" << std::addressof(g) << std::endl;
	std::cout << std::endl;
	std::cout << "STACK		 - f		" << std::addressof(f) << std::endl;
	std::cout << "STACK		 - p		" << std::addressof(p) << std::endl;
	std::cout << std::endl;
	std::cout << "Free Store - *f		" << std::addressof(*f) << std::endl;

}



파일이름: source.cpp
파일크기: 1198
2022-03-24 14:08:24 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include <thread>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);

void foo() {
	std::cout << "foo" << std::endl;
}

int g;

int main() {
	save("source.cpp");

	void(*p)(void) = foo;

	int count{};

	int* f = new int;

	std::cout << "CODE		 - foo		" << std::addressof(foo) << std::endl;
	std::cout << "CODE		 - main		" << std::addressof(main) << std::endl;
	std::cout << "CODE		 - save		" << std::addressof(save) << std::endl;
	std::cout << "CODE		 - *p		" << std::addressof(*p) << std::endl;
	std::cout << std::endl;
	std::cout << "DATA		 - g		" << std::addressof(g) << std::endl;
	std::cout << std::endl;
	std::cout << "STACK		 - f		" << std::addressof(f) << std::endl;
	std::cout << "STACK		 - p		" << std::addressof(p) << std::endl;
	std::cout << std::endl;
	std::cout << "Free Store - *f		" << std::addressof(*f) << std::endl;

}



파일이름: source.cpp
파일크기: 520
2022-03-24 14:16:08 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 2. 람다(lambda)
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include <thread>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);


int main() {
	[]() {
		std::cout << "hi" << std::endl;
		
	};


	save("source.cpp");
}



파일이름: source.cpp
파일크기: 522
2022-03-24 14:16:31 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 2. 람다(lambda)
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include <thread>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);


int main() {
	[]() {
		std::cout << "hi" << std::endl;
		
	}();


	save("source.cpp");
}



파일이름: source.cpp
파일크기: 551
2022-03-24 14:19:10 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 2. 람다(lambda)
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include <thread>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);


int main() {
	
	
	std::cout << typeid([]() {std::cout << "hi" << std::endl; }()).name();

	


	save("source.cpp");
}



파일이름: source.cpp
파일크기: 576
2022-03-24 14:21:00 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 2. 람다(lambda)
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include <thread>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);


int main() {
	
	
	auto x = []() {std::cout << "hi" << std::endl; };

	std::cout << typeid(x).name() << std::endl;
	


	save("source.cpp");
}



파일이름: source.cpp
파일크기: 610
2022-03-24 14:22:17 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 2. 람다(lambda)
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);


int main() {
	
	
	auto x = []() {std::cout << "hi" << std::endl; };

	std::cout << typeid(x).name() << std::endl;
	
	class Dog {};

	std::cout << typeid(Dog).name();


	save("source.cpp");
}



파일이름: source.cpp
파일크기: 613
2022-03-24 14:23:09 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 2. 람다(lambda)
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);


class Dog {};


int main() {
	
	
	auto x = []() {std::cout << "hi" << std::endl; };

	std::cout << typeid(x).name() << std::endl;
	

	std::cout << typeid(Dog).name();


	save("source.cpp");
}



파일이름: source.cpp
파일크기: 610
2022-03-24 14:23:23 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 2. 람다(lambda)
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);


int main() {
	
	
	auto x = []() {std::cout << "hi" << std::endl; };

	std::cout << typeid(x).name() << std::endl;
	
	class Dog {};

	std::cout << typeid(Dog).name();


	save("source.cpp");
}



파일이름: source.cpp
파일크기: 612
2022-03-24 14:23:45 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 2. 람다(lambda)
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);


auto x = []() {std::cout << "hi" << std::endl; };
class Dog {};


int main() {
	
	

	std::cout << typeid(x).name() << std::endl;
	

	std::cout << typeid(Dog).name();


	save("source.cpp");
}



파일이름: source.cpp
파일크기: 612
2022-03-24 14:23:48 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 2. 람다(lambda)
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);


auto x = []() {std::cout << "hi" << std::endl; };
class Dog {};


int main() {
	
	

	std::cout << typeid(x).name() << std::endl;
	

	std::cout << typeid(Dog).name();


	save("source.cpp");
}



파일이름: source.cpp
파일크기: 831
2022-03-24 14:37:52 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 2. 람다(lambda) - 컴파일러가 만들어주는 class이다. (? class가 호출가능 타입?)
 * 3. ()을 오버로딩한 class ()는 함수호출 연산자
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);


class Dog {};


int main() {

	// 람다는 어디서 어떻게 사용해야되나
	std::array<int, 5> a{ 3,1,5,2,4 };

	std::sort(a.begin(), a.end(), [](int a, int b) { return a > b; });

	for (int n : a) {
		std::cout << n << " " << std::endl;
	}

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 818
2022-03-24 14:38:02 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 2. 람다(lambda) - 컴파일러가 만들어주는 class이다. (? class가 호출가능 타입?)
 * 3. ()을 오버로딩한 class ()는 함수호출 연산자
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);


class Dog {};


int main() {

	// 람다는 어디서 어떻게 사용해야되나
	std::array<int, 5> a{ 3,1,5,2,4 };

	std::sort(a.begin(), a.end(), [](int a, int b) { return a > b; });

	for (int n : a) {
		std::cout << n << " ";
	}

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 916
2022-03-24 14:44:22 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 2. 람다(lambda) - 컴파일러가 만들어주는 class이다. (? class가 호출가능 타입?)
 * 3. ()을 오버로딩한 class ()는 함수호출 연산자
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);


class Dog {
public:
	void operator()() { std::cout << "Dog" << std::endl; }
};



int main() {

	// 람다는 어디서 어떻게 사용해야되나
	//std::array<int, 5> a{ 3,1,5,2,4 };

	//std::sort(a.begin(), a.end(), [](int a, int b) { return a > b; });

	//for (int n : a) {
	//	std::cout << n << " ";
	//}

	Dog d;
	d();

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 710
2022-03-24 14:45:05 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 2. 람다(lambda) - 컴파일러가 만들어주는 class이다. (? class가 호출가능 타입?)
 * 3. ()을 오버로딩한 class ()는 함수호출 연산자
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);


class Dog {
public:
	bool operator()(int a, int b) {
		return a > b;
	}
};



int main() {

	Dog dog;
	dog(1,2);

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 818
2022-03-24 14:46:38 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 2. 람다(lambda) - 컴파일러가 만들어주는 class이다. (? class가 호출가능 타입?)
 * 3. ()을 오버로딩한 class ()는 함수호출 연산자
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);


class Dog {
public:
	bool operator()(int a, int b) {
		return a > b;
	}
};



int main() {

	std::array<int, 5> a{ 3,1,5,2,4 };

	std::sort(a.begin(), a.end(), Dog{});

	for (int n : a) {
		std::cout << n << " ";
	}

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 1107
2022-03-24 15:06:40 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 2. 람다(lambda) - 컴파일러가 만들어주는 class이다. (? class가 호출가능 타입?)
 * 3. ()을 오버로딩한 class ()는 함수호출 연산자
 * 4. 멤버함수(method) 포인터
 * 
 * 호출가능한 타입은 무한개이다(람다때문)
 * --> 모든 호출가능타입을 통일된 방식으로 표현할 수 있는 클래스, function
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include <functional>
#include "save.h"

// drmemory, makefile
// 앞으로 사용할 class STRING 작성 시작(RAII)
// 문제: main()이 문제없이 실행되게 하자
// 관찰할 수 있도록 special 함수에 출력메시지를 추가한다

class STRING {
public:
	STRING(const char* c)
		: c(c) {}
	friend std::ostream& operator<<(std::ostream& os, STRING c) {
		os << c;
		return os;
	}
private:
	const char* c;
};

int main() {

	STRING a{ "2022 3 24" };
	STRING b{ "STL STRING 작성 시작" };
	
	std::cout << a << std::endl;
	std::cout << b << std::endl;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 1177
2022-03-24 15:08:24 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 2. 람다(lambda) - 컴파일러가 만들어주는 class이다. (? class가 호출가능 타입?)
 * 3. ()을 오버로딩한 class ()는 함수호출 연산자
 * 4. 멤버함수(method) 포인터
 * 
 * 호출가능한 타입은 무한개이다(람다때문)
 * --> 모든 호출가능타입을 통일된 방식으로 표현할 수 있는 클래스, function
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include <functional>
#include "save.h"

// drmemory, makefile
// 앞으로 사용할 class STRING 작성 시작(RAII)
// 문제: main()이 문제없이 실행되게 하자
// 관찰할 수 있도록 special 함수에 출력메시지를 추가한다

class STRING {
public:
	STRING(const char* c);
	friend std::ostream& operator<<(std::ostream& os, STRING c) {
		os << c;
		return os;
	}
private:
	const char* memory;
};

STRING::STRING(const char* c) {
	memory = new char[10];
	memory = c;
}

int main() {

	STRING a{ "2022 3 24" };
	STRING b{ "STL STRING 작성 시작" };
	
	std::cout << a << std::endl;
	std::cout << b << std::endl;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 1551
2022-03-24 15:20:13 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 2. 람다(lambda) - 컴파일러가 만들어주는 class이다. (? class가 호출가능 타입?)
 * 3. ()을 오버로딩한 class ()는 함수호출 연산자
 * 4. 멤버함수(method) 포인터
 * 
 * 호출가능한 타입은 무한개이다(람다때문)
 * --> 모든 호출가능타입을 통일된 방식으로 표현할 수 있는 클래스, function
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */



 // drmemory, makefile
 // 앞으로 사용할 class STRING 작성 시작(RAII)
 // 문제: main()이 문제없이 실행되게 하자
 // 관찰할 수 있도록 special 함수에 출력메시지를 추가한다
 // 객체가 생성될때마다 고유번호를 준다



#include <iostream>
#include <functional>
#include "save.h"

class STRING {
public:
	STRING(const char* s) : num(strlen(s)), p{ new char[num] } {
		id = ++gid;
		memcpy(p, s, num);
		// 관찰메시지 on
		std::cout << "ctor [" << id << "] 주소: " << this << std::endl;
	}
	~STRING() {
		// 관찰메시지 on
		std::cout << "dtor [" << id << "] 주소: " << this << std::endl;
		delete[] p;
	}


	friend std::ostream& operator<<(std::ostream& os, const STRING& string);

private:
	int num;
	char* p;
	int id;
	static int gid;
};

std::ostream& operator<<(std::ostream& os, const STRING& string);

int STRING::gid{};


int main() {

	STRING a{ "2022 3 24" };
	STRING b{ "STL STRING 작성 시작" };
	
	//std::cout << a << std::endl;
	//std::cout << b << std::endl;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 1592
2022-03-24 15:21:20 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 2. 람다(lambda) - 컴파일러가 만들어주는 class이다. (? class가 호출가능 타입?)
 * 3. ()을 오버로딩한 class ()는 함수호출 연산자
 * 4. 멤버함수(method) 포인터
 * 
 * 호출가능한 타입은 무한개이다(람다때문)
 * --> 모든 호출가능타입을 통일된 방식으로 표현할 수 있는 클래스, function
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */



 // drmemory, makefile
 // 앞으로 사용할 class STRING 작성 시작(RAII)
 // 문제: main()이 문제없이 실행되게 하자
 // 관찰할 수 있도록 special 함수에 출력메시지를 추가한다
 // 객체가 생성될때마다 고유번호를 준다



#include <iostream>
#include <functional>
#include "save.h"

class STRING {
public:
	STRING(const char* s) : num(strlen(s)), p{ new char[num] } {
		id = ++gid;
		memcpy(p, s, num);
		// 관찰메시지 on
		std::cout << "ctor [" << id << "] 주소: " << this << std::endl;
	}
	~STRING() {
		// 관찰메시지 on
		std::cout << "dtor [" << id << "] 주소: " << this << std::endl;
		delete[] p;
	}


	friend std::ostream& operator<<(std::ostream& os, const STRING& string);

private:
	int num;
	char* p;
	int id;
	static int gid;
};

std::ostream& operator<<(std::ostream& os, const STRING& string) {
	std::cout << *string.p;
	return os;
}

int STRING::gid{};


int main() {

	STRING a{ "2022 3 24" };
	STRING b{ "STL STRING 작성 시작" };
	
	std::cout << a << std::endl;
	//std::cout << b << std::endl;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 1638
2022-03-30 17:30:59 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 2. 람다(lambda) - 컴파일러가 만들어주는 class이다. (? class가 호출가능 타입?)
 * 3. ()을 오버로딩한 class ()는 함수호출 연산자
 * 4. 멤버함수(method) 포인터
 * 
 * 호출가능한 타입은 무한개이다(람다때문)
 * --> 모든 호출가능타입을 통일된 방식으로 표현할 수 있는 클래스, function
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */



 // drmemory, makefile
 // 앞으로 사용할 class STRING 작성 시작(RAII)
 // 문제: main()이 문제없이 실행되게 하자
 // 관찰할 수 있도록 special 함수에 출력메시지를 추가한다
 // 객체가 생성될때마다 고유번호를 준다



#include <iostream>
#include <functional>
#include "save.h"

class STRING {
public:
	STRING(const char* s) : num(strlen(s)), p{ new char[num] } {
		id = ++gid;
		memcpy(p, s, num);
		// 관찰메시지 on
		std::cout << "ctor [" << id << "] 주소: " << this << std::endl;
	}
	~STRING() {
		// 관찰메시지 on
		std::cout << "dtor [" << id << "] 주소: " << this << std::endl;
		delete[] p;
	}


	friend std::ostream& operator<<(std::ostream& os, const STRING& string);

private:
	int num;
	char* p;
	int id;
	static int gid;
};

std::ostream& operator<<(std::ostream& os, const STRING& string) {
	for (int i = 0; i < string.num; ++i) {
		std::cout << string.p[i];
	}
	return os;
}

int STRING::gid{};


int main() {

	STRING a{ "2022 3 24" };
	STRING b{ "STL STRING 작성 시작" };
	
	std::cout << a << std::endl;
	std::cout << b << std::endl;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 1682
2022-03-30 17:33:07 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 2. 람다(lambda) - 컴파일러가 만들어주는 class이다. (? class가 호출가능 타입?)
 * 3. ()을 오버로딩한 class ()는 함수호출 연산자
 * 4. 멤버함수(method) 포인터
 * 
 * 호출가능한 타입은 무한개이다(람다때문)
 * --> 모든 호출가능타입을 통일된 방식으로 표현할 수 있는 클래스, function
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */



 // drmemory, makefile
 // 앞으로 사용할 class STRING 작성 시작(RAII)
 // 문제: main()이 문제없이 실행되게 하자
 // 관찰할 수 있도록 special 함수에 출력메시지를 추가한다
 // 객체가 생성될때마다 고유번호를 준다



#include <iostream>
#include <functional>
#include "save.h"

class STRING {
public:
	STRING(const char* s) : num(strlen(s)), p{ new char[num] } {
		id = ++gid;
		memcpy(p, s, num);
		// 관찰메시지 on
		std::cout << "ctor [" << id << "] 주소: " << this << std::endl;
	}
	~STRING() {
		// 관찰메시지 on
		std::cout << "dtor [" << id << "] 주소: " << this << std::endl;
		delete[] p;
	}


	friend std::ostream& operator<<(std::ostream& os, const STRING& string);

private:
	int num;
	char* p;
	int id;
	static int gid;
};

std::ostream& operator<<(std::ostream& os, const STRING& string) {
	for (int i = 0; i < string.num; ++i) {
		std::cout << string.p[i];
	}
	return os;
}

int STRING::gid{};


int main() {
	std::cout << sizeof(STRING) << std::endl;

	STRING a{ "2022 3 24" };
	STRING b{ "STL STRING 작성 시작" };
	
	std::cout << a << std::endl;
	std::cout << b << std::endl;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 1929
2022-03-30 17:52:23 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 2. 람다(lambda) - 컴파일러가 만들어주는 class이다. (? class가 호출가능 타입?)
 * 3. ()을 오버로딩한 class ()는 함수호출 연산자
 * 4. 멤버함수(method) 포인터
 * 
 * 호출가능한 타입은 무한개이다(람다때문)
 * --> 모든 호출가능타입을 통일된 방식으로 표현할 수 있는 클래스, function
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */



 // drmemory, makefile
 // 앞으로 사용할 class STRING 작성 시작(RAII)
 // 문제: main()이 문제없이 실행되게 하자
 // 관찰할 수 있도록 special 함수에 출력메시지를 추가한다
 // 객체가 생성될때마다 고유번호를 준다



#include <iostream>
#include <functional>
#include "save.h"

bool debug{ false };

class STRING {
public:
	STRING(const char* s) : num{ strlen(s) }, id{ ++gid } {
		p = new char[num];
		memcpy(p, s, num);
		
		// 관찰메시지 on
		if (debug) {
			print("소멸자");
		}
		if (num) {
			delete[] p;
		}
	}

	~STRING() {
		// 관찰메시지 on
		std::cout << "dtor [" << id << "] 주소: " << this << std::endl;
		delete[] p;
	}

	void print(const char* s) const {
		std::cout << s << " [" << id << "] 객체: " << this;
		if (num) {
			std::cout << " - 자원: " << num << " 주소: " << (void*)p;
		}
		else {
			std::cout << " - 자원없음";
		}
		std::cout << std::endl;
	}


	friend std::ostream& operator<<(std::ostream& os, const STRING& string);

private:
	size_t num;
	char* p;
	int id;
	static int gid;
};

std::ostream& operator<<(std::ostream& os, const STRING& string) {
	for (size_t i{}; i < string.num; ++i) {
		os << string.p[i];
	}
	return os;
}


int STRING::gid{};


int main() {
	STRING a{ "2022 3 24" };
	STRING b{ "STL STRING 작성 시작" };
	
	std::cout << a << std::endl;
	std::cout << b << std::endl;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 1929
2022-03-30 17:52:29 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 2. 람다(lambda) - 컴파일러가 만들어주는 class이다. (? class가 호출가능 타입?)
 * 3. ()을 오버로딩한 class ()는 함수호출 연산자
 * 4. 멤버함수(method) 포인터
 * 
 * 호출가능한 타입은 무한개이다(람다때문)
 * --> 모든 호출가능타입을 통일된 방식으로 표현할 수 있는 클래스, function
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */



 // drmemory, makefile
 // 앞으로 사용할 class STRING 작성 시작(RAII)
 // 문제: main()이 문제없이 실행되게 하자
 // 관찰할 수 있도록 special 함수에 출력메시지를 추가한다
 // 객체가 생성될때마다 고유번호를 준다



#include <iostream>
#include <functional>
#include "save.h"

bool debug{ false };

class STRING {
public:
	STRING(const char* s) : num{ strlen(s) }, id{ ++gid } {
		p = new char[num];
		memcpy(p, s, num);
		
		// 관찰메시지 on
		if (debug) {
			print("소멸자");
		}
		if (num) {
			delete[] p;
		}
	}

	~STRING() {
		// 관찰메시지 on
		std::cout << "dtor [" << id << "] 주소: " << this << std::endl;
		delete[] p;
	}

	void print(const char* s) const {
		std::cout << s << " [" << id << "] 객체: " << this;
		if (num) {
			std::cout << " - 자원: " << num << " 주소: " << (void*)p;
		}
		else {
			std::cout << " - 자원없음";
		}
		std::cout << std::endl;
	}


	friend std::ostream& operator<<(std::ostream& os, const STRING& string);

private:
	size_t num;
	char* p;
	int id;
	static int gid;
};

std::ostream& operator<<(std::ostream& os, const STRING& string) {
	for (size_t i{}; i < string.num; ++i) {
		os << string.p[i];
	}
	return os;
}


int STRING::gid{};


int main() {
	STRING a{ "2022 3 24" };
	STRING b{ "STL STRING 작성 시작" };
	
	std::cout << a << std::endl;
	std::cout << b << std::endl;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 1869
2022-03-30 17:53:17 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 2. 람다(lambda) - 컴파일러가 만들어주는 class이다. (? class가 호출가능 타입?)
 * 3. ()을 오버로딩한 class ()는 함수호출 연산자
 * 4. 멤버함수(method) 포인터
 * 
 * 호출가능한 타입은 무한개이다(람다때문)
 * --> 모든 호출가능타입을 통일된 방식으로 표현할 수 있는 클래스, function
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */



 // drmemory, makefile
 // 앞으로 사용할 class STRING 작성 시작(RAII)
 // 문제: main()이 문제없이 실행되게 하자
 // 관찰할 수 있도록 special 함수에 출력메시지를 추가한다
 // 객체가 생성될때마다 고유번호를 준다



#include <iostream>
#include <functional>
#include "save.h"

bool debug{ false };

class STRING {
public:
	STRING(const char* s) : num{ strlen(s) }, id{ ++gid } {
		p = new char[num];
		memcpy(p, s, num);
		
		// 관찰메시지 on
		if (debug) {
			print("생성자");
		}
	}

	~STRING() {
		if (debug) {
			print("소멸자");
		}
		if (num) {
			delete[] p;
		}
	}

	void print(const char* s) const {
		std::cout << s << " [" << id << "] 객체: " << this;
		if (num) {
			std::cout << " - 자원: " << num << " 주소: " << (void*)p;
		}
		else {
			std::cout << " - 자원없음";
		}
		std::cout << std::endl;
	}


	friend std::ostream& operator<<(std::ostream& os, const STRING& string);

private:
	size_t num;
	char* p;
	int id;
	static int gid;
};

std::ostream& operator<<(std::ostream& os, const STRING& string) {
	for (size_t i{}; i < string.num; ++i) {
		os << string.p[i];
	}
	return os;
}


int STRING::gid{};


int main() {
	STRING a{ "2022 3 24" };
	STRING b{ "STL STRING 작성 시작" };
	
	std::cout << a << std::endl;
	std::cout << b << std::endl;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 1868
2022-03-30 17:53:24 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 2. 람다(lambda) - 컴파일러가 만들어주는 class이다. (? class가 호출가능 타입?)
 * 3. ()을 오버로딩한 class ()는 함수호출 연산자
 * 4. 멤버함수(method) 포인터
 * 
 * 호출가능한 타입은 무한개이다(람다때문)
 * --> 모든 호출가능타입을 통일된 방식으로 표현할 수 있는 클래스, function
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */



 // drmemory, makefile
 // 앞으로 사용할 class STRING 작성 시작(RAII)
 // 문제: main()이 문제없이 실행되게 하자
 // 관찰할 수 있도록 special 함수에 출력메시지를 추가한다
 // 객체가 생성될때마다 고유번호를 준다



#include <iostream>
#include <functional>
#include "save.h"

bool debug{ true };

class STRING {
public:
	STRING(const char* s) : num{ strlen(s) }, id{ ++gid } {
		p = new char[num];
		memcpy(p, s, num);
		
		// 관찰메시지 on
		if (debug) {
			print("생성자");
		}
	}

	~STRING() {
		if (debug) {
			print("소멸자");
		}
		if (num) {
			delete[] p;
		}
	}

	void print(const char* s) const {
		std::cout << s << " [" << id << "] 객체: " << this;
		if (num) {
			std::cout << " - 자원: " << num << " 주소: " << (void*)p;
		}
		else {
			std::cout << " - 자원없음";
		}
		std::cout << std::endl;
	}


	friend std::ostream& operator<<(std::ostream& os, const STRING& string);

private:
	size_t num;
	char* p;
	int id;
	static int gid;
};

std::ostream& operator<<(std::ostream& os, const STRING& string) {
	for (size_t i{}; i < string.num; ++i) {
		os << string.p[i];
	}
	return os;
}


int STRING::gid{};


int main() {
	STRING a{ "2022 3 24" };
	STRING b{ "STL STRING 작성 시작" };
	
	std::cout << a << std::endl;
	std::cout << b << std::endl;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 1868
2022-03-30 17:53:28 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 2. 람다(lambda) - 컴파일러가 만들어주는 class이다. (? class가 호출가능 타입?)
 * 3. ()을 오버로딩한 class ()는 함수호출 연산자
 * 4. 멤버함수(method) 포인터
 * 
 * 호출가능한 타입은 무한개이다(람다때문)
 * --> 모든 호출가능타입을 통일된 방식으로 표현할 수 있는 클래스, function
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */



 // drmemory, makefile
 // 앞으로 사용할 class STRING 작성 시작(RAII)
 // 문제: main()이 문제없이 실행되게 하자
 // 관찰할 수 있도록 special 함수에 출력메시지를 추가한다
 // 객체가 생성될때마다 고유번호를 준다



#include <iostream>
#include <functional>
#include "save.h"

bool debug{ true };

class STRING {
public:
	STRING(const char* s) : num{ strlen(s) }, id{ ++gid } {
		p = new char[num];
		memcpy(p, s, num);
		
		// 관찰메시지 on
		if (debug) {
			print("생성자");
		}
	}

	~STRING() {
		if (debug) {
			print("소멸자");
		}
		if (num) {
			delete[] p;
		}
	}

	void print(const char* s) const {
		std::cout << s << " [" << id << "] 객체: " << this;
		if (num) {
			std::cout << " - 자원: " << num << " 주소: " << (void*)p;
		}
		else {
			std::cout << " - 자원없음";
		}
		std::cout << std::endl;
	}


	friend std::ostream& operator<<(std::ostream& os, const STRING& string);

private:
	size_t num;
	char* p;
	int id;
	static int gid;
};

std::ostream& operator<<(std::ostream& os, const STRING& string) {
	for (size_t i{}; i < string.num; ++i) {
		os << string.p[i];
	}
	return os;
}


int STRING::gid{};


int main() {
	STRING a{ "2022 3 24" };
	STRING b{ "STL STRING 작성 시작" };
	
	std::cout << a << std::endl;
	std::cout << b << std::endl;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 1923
2022-03-30 17:54:48 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 2. 람다(lambda) - 컴파일러가 만들어주는 class이다. (? class가 호출가능 타입?)
 * 3. ()을 오버로딩한 class ()는 함수호출 연산자
 * 4. 멤버함수(method) 포인터
 * 
 * 호출가능한 타입은 무한개이다(람다때문)
 * --> 모든 호출가능타입을 통일된 방식으로 표현할 수 있는 클래스, function
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */



 // drmemory, makefile
 // 앞으로 사용할 class STRING 작성 시작(RAII)
 // 문제: main()이 문제없이 실행되게 하자
 // 관찰할 수 있도록 special 함수에 출력메시지를 추가한다
 // 객체가 생성될때마다 고유번호를 준다



#include <iostream>
#include <functional>
#include "save.h"

bool debug{ true };

class STRING {
public:
	STRING(const char* s) : num{ strlen(s) }, id{ ++gid } {
		p = new char[num];
		memcpy(p, s, num);
		
		// 관찰메시지 on
		if (debug) {
			print("생성자");
		}
	}

	~STRING() {
		if (debug) {
			print("소멸자");
		}
		if (num) {
			delete[] p;
		}
	}

	void print(const char* s) const {
		std::cout << s << " [" << id << "] 객체: " << this;
		if (num) {
			std::cout << " - 자원: " << num << " 주소: " << (void*)p;
		}
		else {
			std::cout << " - 자원없음";
		}
		std::cout << std::endl;
	}


	friend std::ostream& operator<<(std::ostream& os, const STRING& string);

private:
	size_t num;
	char* p;
	int id;
	static int gid;
};

std::ostream& operator<<(std::ostream& os, const STRING& string) {
	for (size_t i{}; i < string.num; ++i) {
		os << string.p[i];
	}
	return os;
}


int STRING::gid{};


int main() {
	STRING a{ "2022 3 24" };
	STRING b{ "STL STRING 작성 시작" };
	//STRING c = a + b;
	
	std::cout << a << std::endl;
	std::cout << b << std::endl;
	//std::cout << c << std::endl;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 2353
2022-03-30 18:23:03 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 2. 람다(lambda) - 컴파일러가 만들어주는 class이다. (? class가 호출가능 타입?)
 * 3. ()을 오버로딩한 class ()는 함수호출 연산자
 * 4. 멤버함수(method) 포인터
 * 
 * 호출가능한 타입은 무한개이다(람다때문)
 * --> 모든 호출가능타입을 통일된 방식으로 표현할 수 있는 클래스, function
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */



 // drmemory, makefile
 // 앞으로 사용할 class STRING 작성 시작(RAII)
 // 문제: main()이 문제없이 실행되게 하자
 // 관찰할 수 있도록 special 함수에 출력메시지를 추가한다
 // 객체가 생성될때마다 고유번호를 준다



#include <iostream>
#include <functional>
#include "save.h"

bool debug{ false };

class STRING {
public:
	STRING() : num{}, p{}, id{ ++gid } {
		print("디폴트 생성자");
	}
	STRING(const char* s) : num{ strlen(s) }, id{ ++gid } {
		p = new char[num];
		memcpy(p, s, num);
		
		// 관찰메시지 on
		if (debug) {
			print("생성자");
		}
	}

	~STRING() {
		if (debug) {
			print("소멸자");
		}
		if (num) {
			delete[] p;
		}
	}

	STRING operator+(const STRING& rhs) const {
		STRING temp;
		temp.num = num + rhs.num;
		temp.p = new char[temp.num];

		memcpy(temp.p, p, num);
		memcpy(temp.p + num, rhs.p, rhs.num);

		return temp;
	}

	void print(const char* s) const {
		std::cout << s << " [" << id << "] 객체: " << this;
		if (num) {
			std::cout << " - 자원: " << num << " 주소: " << (void*)p;
		}
		else {
			std::cout << " - 자원없음";
		}
		std::cout << std::endl;
	}


	friend std::ostream& operator<<(std::ostream& os, const STRING& string);

private:
	size_t num;							// 관리하는 자원 수
	char* p;							// 자원의 주소
	int id;								// 생성 시 부여한 고유값
	static int gid;						// 아이디 생성용
};

std::ostream& operator<<(std::ostream& os, const STRING& string) {
	for (size_t i{}; i < string.num; ++i) {
		os << string.p[i];
	}
	return os;
}


int STRING::gid{};


int main() {
	debug = true;

	STRING a{ "2022 " };
	STRING b{ "3 24" };
	//STRING c = a + b;
	
	std::cout << a + b << std::endl;


	//std::cout << a << std::endl;
	//std::cout << b << std::endl;
	//std::cout << c << std::endl;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 2353
2022-03-30 18:23:29 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 2. 람다(lambda) - 컴파일러가 만들어주는 class이다. (? class가 호출가능 타입?)
 * 3. ()을 오버로딩한 class ()는 함수호출 연산자
 * 4. 멤버함수(method) 포인터
 * 
 * 호출가능한 타입은 무한개이다(람다때문)
 * --> 모든 호출가능타입을 통일된 방식으로 표현할 수 있는 클래스, function
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */



 // drmemory, makefile
 // 앞으로 사용할 class STRING 작성 시작(RAII)
 // 문제: main()이 문제없이 실행되게 하자
 // 관찰할 수 있도록 special 함수에 출력메시지를 추가한다
 // 객체가 생성될때마다 고유번호를 준다



#include <iostream>
#include <functional>
#include "save.h"

bool debug{ false };

class STRING {
public:
	STRING() : num{}, p{}, id{ ++gid } {
		print("디폴트 생성자");
	}
	STRING(const char* s) : num{ strlen(s) }, id{ ++gid } {
		p = new char[num];
		memcpy(p, s, num);
		
		// 관찰메시지 on
		if (debug) {
			print("생성자");
		}
	}

	~STRING() {
		if (debug) {
			print("소멸자");
		}
		if (num) {
			delete[] p;
		}
	}

	STRING operator+(const STRING& rhs) const {
		STRING temp;
		temp.num = num + rhs.num;
		temp.p = new char[temp.num];

		memcpy(temp.p, p, num);
		memcpy(temp.p + num, rhs.p, rhs.num);

		return temp;
	}

	void print(const char* s) const {
		std::cout << s << " [" << id << "] 객체: " << this;
		if (num) {
			std::cout << " - 자원: " << num << " 주소: " << (void*)p;
		}
		else {
			std::cout << " - 자원없음";
		}
		std::cout << std::endl;
	}


	friend std::ostream& operator<<(std::ostream& os, const STRING& string);

private:
	size_t num;							// 관리하는 자원 수
	char* p;							// 자원의 주소
	int id;								// 생성 시 부여한 고유값
	static int gid;						// 아이디 생성용
};

std::ostream& operator<<(std::ostream& os, const STRING& string) {
	for (size_t i{}; i < string.num; ++i) {
		os << string.p[i];
	}
	return os;
}


int STRING::gid{};


int main() {
	debug = true;

	STRING a{ "2022 " };
	STRING b{ "3 24" };
	//STRING c = a + b;
	
	std::cout << a + b << std::endl;


	//std::cout << a << std::endl;
	//std::cout << b << std::endl;
	//std::cout << c << std::endl;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 2309
2022-03-30 18:24:21 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 2. 람다(lambda) - 컴파일러가 만들어주는 class이다. (? class가 호출가능 타입?)
 * 3. ()을 오버로딩한 class ()는 함수호출 연산자
 * 4. 멤버함수(method) 포인터
 * 
 * 호출가능한 타입은 무한개이다(람다때문)
 * --> 모든 호출가능타입을 통일된 방식으로 표현할 수 있는 클래스, function
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */



 // drmemory, makefile
 // 앞으로 사용할 class STRING 작성 시작(RAII)
 // 문제: main()이 문제없이 실행되게 하자
 // 관찰할 수 있도록 special 함수에 출력메시지를 추가한다
 // 객체가 생성될때마다 고유번호를 준다



#include <iostream>
#include <functional>
#include "save.h"

bool debug{ false };

class STRING {
public:
	STRING() : num{}, p{}, id{ ++gid } {
		print("디폴트 생성자");
	}
	STRING(const char* s) : num{ strlen(s) }, id{ ++gid } {
		p = new char[num];
		memcpy(p, s, num);
		
		// 관찰메시지 on
		if (debug) {
			print("생성자");
		}
	}

	~STRING() {
		if (debug) {
			print("소멸자");
		}
		if (num) {
			delete[] p;
		}
	}

	STRING operator+(const STRING& rhs) const {
		STRING temp;
		temp.num = num + rhs.num;
		temp.p = new char[temp.num];

		memcpy(temp.p, p, num);
		memcpy(temp.p + num, rhs.p, rhs.num);

		return temp;
	}

	void print(const char* s) const {
		std::cout << s << " [" << id << "] 객체: " << this;
		if (num) {
			std::cout << " - 자원: " << num << " 주소: " << (void*)p;
		}
		else {
			std::cout << " - 자원없음";
		}
		std::cout << std::endl;
	}


	friend std::ostream& operator<<(std::ostream& os, const STRING& string);

private:
	size_t num;							// 관리하는 자원 수
	char* p;							// 자원의 주소
	int id;								// 생성 시 부여한 고유값
	static int gid;						// 아이디 생성용
};

std::ostream& operator<<(std::ostream& os, const STRING& string) {
	for (size_t i{}; i < string.num; ++i) {
		os << string.p[i];
	}
	return os;
}


int STRING::gid{};


int main() {
	debug = true;

	STRING a{ "2022 " };
	STRING b{ "3 24" };
	STRING c = a + b;

	//std::cout << a << std::endl;
	//std::cout << b << std::endl;
	std::cout << c << std::endl;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 2750
2022-03-30 18:30:39 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 2. 람다(lambda) - 컴파일러가 만들어주는 class이다. (? class가 호출가능 타입?)
 * 3. ()을 오버로딩한 class ()는 함수호출 연산자
 * 4. 멤버함수(method) 포인터
 * 
 * 호출가능한 타입은 무한개이다(람다때문)
 * --> 모든 호출가능타입을 통일된 방식으로 표현할 수 있는 클래스, function
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */



 // drmemory, makefile
 // 앞으로 사용할 class STRING 작성 시작(RAII)
 // 문제: main()이 문제없이 실행되게 하자
 // 관찰할 수 있도록 special 함수에 출력메시지를 추가한다
 // 객체가 생성될때마다 고유번호를 준다



#include <iostream>
#include <functional>
#include "save.h"

bool printMsg{ false };

class STRING {
public:
	STRING() : num{}, p{}, id{ ++gid } {
		print("디폴트 생성자");
	}

	STRING(const char* s) : num{ strlen(s) }, id{ ++gid } {
		p = new char[num];
		memcpy(p, s, num);
		
		// 관찰메시지 on
		if (printMsg) {
			print("생성자");
		}
	}

	~STRING() {
		if (printMsg) {
			print("소멸자");
		}
		if (num) {
			delete[] p;
		}
	}

	STRING(const STRING& other) : num{ other.num }, id { ++gid } {
		p = new char[num];
		memcpy(p, other.p, num);
		if (printMsg) {
			print("복사생성자");
		}
	}

	STRING& operator=(const STRING& other) {
		if (this == &other) {
			return *this;
		}
		
		if (num) {
			delete[] p;
		}

		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);

		if (printMsg) {
			print("복사할당");
		}
	}

	STRING operator+(const STRING& rhs) const {
		STRING temp;
		temp.num = num + rhs.num;
		temp.p = new char[temp.num];

		memcpy(temp.p, p, num);
		memcpy(temp.p + num, rhs.p, rhs.num);

		return temp;
	}

	void print(const char* s) const {
		std::cout << s << " [" << id << "] 객체: " << this;
		if (num) {
			std::cout << " - 자원: " << num << " 주소: " << (void*)p;
		}
		else {
			std::cout << " - 자원없음";
		}
		std::cout << std::endl;
	}


	friend std::ostream& operator<<(std::ostream& os, const STRING& string);

private:
	size_t num;							// 관리하는 자원 수
	char* p;							// 자원의 주소
	int id;								// 생성 시 부여한 고유값
	static int gid;						// 아이디 생성용
};

std::ostream& operator<<(std::ostream& os, const STRING& string) {
	for (size_t i{}; i < string.num; ++i) {
		os << string.p[i];
	}
	return os;
}


int STRING::gid{};


int main() {
	printMsg = true;

	STRING a{ "2022 " };
	STRING b{ "3 24" };
	STRING c = a + b;

	//std::cout << a << std::endl;
	//std::cout << b << std::endl;
	std::cout << c << std::endl;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 2750
2022-03-30 18:31:40 GMT+9

/*
 * 2022. 03. 24
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type)
 * 1. 함수포인터 - CODE에서 해당함수의 시작번지를 저장
 * 2. 람다(lambda) - 컴파일러가 만들어주는 class이다. (? class가 호출가능 타입?)
 * 3. ()을 오버로딩한 class ()는 함수호출 연산자
 * 4. 멤버함수(method) 포인터
 * 
 * 호출가능한 타입은 무한개이다(람다때문)
 * --> 모든 호출가능타입을 통일된 방식으로 표현할 수 있는 클래스, function
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */



 // drmemory, makefile
 // 앞으로 사용할 class STRING 작성 시작(RAII)
 // 문제: main()이 문제없이 실행되게 하자
 // 관찰할 수 있도록 special 함수에 출력메시지를 추가한다
 // 객체가 생성될때마다 고유번호를 준다



#include <iostream>
#include <functional>
#include "save.h"

bool printMsg{ false };

class STRING {
public:
	STRING() : num{}, p{}, id{ ++gid } {
		print("디폴트 생성자");
	}

	STRING(const char* s) : num{ strlen(s) }, id{ ++gid } {
		p = new char[num];
		memcpy(p, s, num);
		
		// 관찰메시지 on
		if (printMsg) {
			print("생성자");
		}
	}

	~STRING() {
		if (printMsg) {
			print("소멸자");
		}
		if (num) {
			delete[] p;
		}
	}

	STRING(const STRING& other) : num{ other.num }, id { ++gid } {
		p = new char[num];
		memcpy(p, other.p, num);
		if (printMsg) {
			print("복사생성자");
		}
	}

	STRING& operator=(const STRING& other) {
		if (this == &other) {
			return *this;
		}
		
		if (num) {
			delete[] p;
		}

		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);

		if (printMsg) {
			print("복사할당");
		}
	}

	STRING operator+(const STRING& rhs) const {
		STRING temp;
		temp.num = num + rhs.num;
		temp.p = new char[temp.num];

		memcpy(temp.p, p, num);
		memcpy(temp.p + num, rhs.p, rhs.num);

		return temp;
	}

	void print(const char* s) const {
		std::cout << s << " [" << id << "] 객체: " << this;
		if (num) {
			std::cout << " - 자원: " << num << " 주소: " << (void*)p;
		}
		else {
			std::cout << " - 자원없음";
		}
		std::cout << std::endl;
	}


	friend std::ostream& operator<<(std::ostream& os, const STRING& string);

private:
	size_t num;							// 관리하는 자원 수
	char* p;							// 자원의 주소
	int id;								// 생성 시 부여한 고유값
	static int gid;						// 아이디 생성용
};

std::ostream& operator<<(std::ostream& os, const STRING& string) {
	for (size_t i{}; i < string.num; ++i) {
		os << string.p[i];
	}
	return os;
}


int STRING::gid{};


int main() {
	printMsg = true;

	STRING a{ "2022 " };
	STRING b{ "3 24" };
	STRING c = a + b;

	//std::cout << a << std::endl;
	//std::cout << b << std::endl;
	std::cout << c << std::endl;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 2366
2022-03-30 18:38:35 GMT+9

/*
 * 2022. 03. 30
 * STL Class
 * Week 5
 * 
 * 컴파일러 최적화 - RVO(return value optimization), copy ellision
 */



 // drmemory, makefile
 // 앞으로 사용할 class STRING 작성 시작(RAII)
 // 문제: main()이 문제없이 실행되게 하자
 // 관찰할 수 있도록 special 함수에 출력메시지를 추가한다
 // 객체가 생성될때마다 고유번호를 준다



#include <iostream>
#include <functional>
#include "save.h"

bool printMsg{ false };

class STRING {
public:
	STRING() : num{}, p{}, id{ ++gid } {
		print("디폴트 생성자");
	}

	STRING(const char* s) : num{ strlen(s) }, id{ ++gid } {
		p = new char[num];
		memcpy(p, s, num);
		
		// 관찰메시지 on
		if (printMsg) {
			print("생성자");
		}
	}

	~STRING() {
		if (printMsg) {
			print("소멸자");
		}
		if (num) {
			delete[] p;
		}
	}

	STRING(const STRING& other) : num{ other.num }, id { ++gid } {
		p = new char[num];
		memcpy(p, other.p, num);
		if (printMsg) {
			print("복사생성자");
		}
	}

	STRING& operator=(const STRING& other) {
		if (this == &other) {
			return *this;
		}
		
		if (num) {
			delete[] p;
		}

		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);

		if (printMsg) {
			print("할당");
		}
	}

	STRING operator+(const STRING& rhs) const {
		STRING temp;
		temp.num = num + rhs.num;
		temp.p = new char[temp.num];

		memcpy(temp.p, p, num);
		memcpy(temp.p + num, rhs.p, rhs.num);

		return temp;
	}

	void print(const char* s) const {
		std::cout << s << " [" << id << "] 객체: " << this;
		if (num) {
			std::cout << " - 자원: " << num << " 주소: " << (void*)p;
		}
		else {
			std::cout << " - 자원없음";
		}
		std::cout << std::endl;
	}


	friend std::ostream& operator<<(std::ostream& os, const STRING& string);

private:
	size_t num;							// 관리하는 자원 수
	char* p;							// 자원의 주소
	int id;								// 생성 시 부여한 고유값
	static int gid;						// 아이디 생성용
};

std::ostream& operator<<(std::ostream& os, const STRING& string) {
	for (size_t i{}; i < string.num; ++i) {
		os << string.p[i];
	}
	return os;
}


int STRING::gid{};


int main() {
	printMsg = true;

	STRING a{ "2022 " };
	STRING b{ "3 24" };
	STRING c = a + b;

	//std::cout << a << std::endl;
	//std::cout << b << std::endl;
	std::cout << c << std::endl;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 585
2022-03-30 18:50:13 GMT+9

/*
 * 2022. 03. 30
 * STL Class
 * Week 5
 * 
 * STRING 클래스 파일 분리
 */



 // drmemory, makefile
 // 앞으로 사용할 class STRING 작성 시작(RAII)
 // 문제: main()이 문제없이 실행되게 하자
 // 관찰할 수 있도록 special 함수에 출력메시지를 추가한다
 // 객체가 생성될때마다 고유번호를 준다



#include <iostream>
#include "save.h"
#include "STRING.h"


int main() {

	STRING a{ "2022 " };
	STRING b{ "3 24" };
	STRING c = a + b;

	//std::cout << a << std::endl;
	//std::cout << b << std::endl;
	std::cout << c << std::endl;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 585
2022-03-30 18:50:28 GMT+9

/*
 * 2022. 03. 30
 * STL Class
 * Week 5
 * 
 * STRING 클래스 파일 분리
 */



 // drmemory, makefile
 // 앞으로 사용할 class STRING 작성 시작(RAII)
 // 문제: main()이 문제없이 실행되게 하자
 // 관찰할 수 있도록 special 함수에 출력메시지를 추가한다
 // 객체가 생성될때마다 고유번호를 준다



#include <iostream>
#include "save.h"
#include "STRING.h"


int main() {

	STRING a{ "2022 " };
	STRING b{ "3 24" };
	STRING c = a + b;

	//std::cout << a << std::endl;
	//std::cout << b << std::endl;
	std::cout << c << std::endl;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 484
2022-03-30 18:51:21 GMT+9

/*
 * 2022. 03. 30
 * STL Class
 * Week 5
 * 
 * STRING 클래스 파일 분리
 */



 // drmemory, makefile
 // 앞으로 사용할 class STRING 작성 시작(RAII)
 // 문제: main()이 문제없이 실행되게 하자
 // 관찰할 수 있도록 special 함수에 출력메시지를 추가한다
 // 객체가 생성될때마다 고유번호를 준다



#include <iostream>
#include "save.h"
#include "STRING.h"


int main() {

	std::cout << STRING{ "123" } + STRING{ "456" } << std::endl;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 526
2022-03-30 18:51:53 GMT+9

/*
 * 2022. 03. 30
 * STL Class
 * Week 5
 * 
 * STRING 클래스 파일 분리
 */



 // drmemory, makefile
 // 앞으로 사용할 class STRING 작성 시작(RAII)
 // 문제: main()이 문제없이 실행되게 하자
 // 관찰할 수 있도록 special 함수에 출력메시지를 추가한다
 // 객체가 생성될때마다 고유번호를 준다



#include <iostream>
#include "save.h"
#include "STRING.h"


int main() {

	std::cout << STRING{ "123" } + STRING{ "456" } << std::endl;

	save("source.cpp");
	save("STRING.h");
	save("STRING.hpp");
}



파일이름: STRING.h
파일크기: 694
2022-03-30 18:51:53 GMT+9

/*
 * 2022. 03. 30
 * STL Class
 * Week 5
 *
 * STRING	- STL 내부 동작을 관찰하려고 만든 자원을 관리하는 클래스
 *			- std::string 동작 대부분을 직접 구현하며 STL 동작방식을 이해
 */

#pragma once

class STRING {
public:
	STRING();
	STRING(const char* s);

	~STRING();

	STRING(const STRING& other);

	STRING& operator=(const STRING& other);
	STRING operator+(const STRING& rhs) const;

	void print(const char* s) const;

	friend std::ostream& operator<<(std::ostream& os, const STRING& string);

private:
	size_t num;							// 관리하는 자원 수
	char* p;							// 자원의 주소
	int id;								// 생성 시 부여한 고유값
	static int gid;						// 아이디 생성용
};



파일이름: source.cpp
파일크기: 526
2022-03-30 18:52:07 GMT+9

/*
 * 2022. 03. 30
 * STL Class
 * Week 5
 * 
 * STRING 클래스 파일 분리
 */



 // drmemory, makefile
 // 앞으로 사용할 class STRING 작성 시작(RAII)
 // 문제: main()이 문제없이 실행되게 하자
 // 관찰할 수 있도록 special 함수에 출력메시지를 추가한다
 // 객체가 생성될때마다 고유번호를 준다



#include <iostream>
#include "save.h"
#include "STRING.h"


int main() {

	std::cout << STRING{ "123" } + STRING{ "456" } << std::endl;

	save("source.cpp");
	save("STRING.h");
	save("STRING.cpp");
}



파일이름: STRING.h
파일크기: 694
2022-03-30 18:52:07 GMT+9

/*
 * 2022. 03. 30
 * STL Class
 * Week 5
 *
 * STRING	- STL 내부 동작을 관찰하려고 만든 자원을 관리하는 클래스
 *			- std::string 동작 대부분을 직접 구현하며 STL 동작방식을 이해
 */

#pragma once

class STRING {
public:
	STRING();
	STRING(const char* s);

	~STRING();

	STRING(const STRING& other);

	STRING& operator=(const STRING& other);
	STRING operator+(const STRING& rhs) const;

	void print(const char* s) const;

	friend std::ostream& operator<<(std::ostream& os, const STRING& string);

private:
	size_t num;							// 관리하는 자원 수
	char* p;							// 자원의 주소
	int id;								// 생성 시 부여한 고유값
	static int gid;						// 아이디 생성용
};



파일이름: STRING.cpp
파일크기: 1509
2022-03-30 18:52:07 GMT+9



#include <iostream>
#include "STRING.h"

int printMsg{ false };
int STRING::gid{};



STRING::STRING() : num{}, p{}, id{ ++gid } {
	if (printMsg) {
		print("디폴트 생성자");
	}
}

STRING::STRING(const char* s) : num{ strlen(s) }, id{ ++gid } {
	p = new char[num];
	memcpy(p, s, num);

	// 관찰메시지 on
	if (printMsg) {
		print("생성자");
	}
}

STRING::~STRING() {
	if (printMsg) {
		print("소멸자");
	}
	if (num) {
		delete[] p;
	}
}

STRING::STRING(const STRING& other) : num{ other.num }, id{ ++gid } {
	p = new char[num];
	memcpy(p, other.p, num);
	if (printMsg) {
		print("복사생성자");
	}
}

STRING& STRING::operator=(const STRING& other) {
	if (this == &other) {
		return *this;
	}

	if (num) {
		delete[] p;
	}

	num = other.num;
	p = new char[num];
	memcpy(p, other.p, num);

	if (printMsg) {
		print("할당");
	}
}

STRING STRING::operator+(const STRING& rhs) const {
	STRING temp;
	temp.num = num + rhs.num;
	temp.p = new char[temp.num];

	memcpy(temp.p, p, num);
	memcpy(temp.p + num, rhs.p, rhs.num);

	return temp;
}

void STRING::print(const char* s) const {
	std::cout << s << " [" << id << "] 객체: " << this;
	if (num) {
		std::cout << " - 자원: " << num << " 주소: " << (void*)p;
	}
	else {
		std::cout << " - 자원없음";
	}
	std::cout << std::endl;
}

std::ostream& operator<<(std::ostream& os, const STRING& string) {
	for (size_t i{}; i < string.num; ++i) {
		os << string.p[i];
	}
	return os;
}



파일이름: source.cpp
파일크기: 526
2022-03-30 18:55:27 GMT+9

/*
 * 2022. 03. 30
 * STL Class
 * Week 5
 * 
 * STRING 클래스 파일 분리
 */



 // drmemory, makefile
 // 앞으로 사용할 class STRING 작성 시작(RAII)
 // 문제: main()이 문제없이 실행되게 하자
 // 관찰할 수 있도록 special 함수에 출력메시지를 추가한다
 // 객체가 생성될때마다 고유번호를 준다



#include <iostream>
#include "save.h"
#include "STRING.h"

extern bool printMsg;

int main() {
	printMsg = true;

	std::cout << STRING{ "123" } + STRING{ "456" } << std::endl;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 632
2022-03-30 19:04:05 GMT+9

/*
 * 2022. 03. 30
 * STL Class
 * Week 5
 * 
 * STRING 클래스 파일 분리
 */



 // drmemory, makefile
 // 앞으로 사용할 class STRING 작성 시작(RAII)
 // 문제: main()이 문제없이 실행되게 하자
 // 관찰할 수 있도록 special 함수에 출력메시지를 추가한다
 // 객체가 생성될때마다 고유번호를 준다



#include <iostream>
#include <array>
#include <vector>
#include "save.h"

#include "STRING.h"
extern bool printMsg;

int main() {
	std::array<STRING, 3> a{ "2022", "3", "30" };
	
	int count = a.size();

	for (int i = 0; i < count; ++i) {
		std::cout << a[i] << std::endl;
	}
	
	save("source.cpp");
}



파일이름: source.cpp
파일크기: 577
2022-03-30 19:04:36 GMT+9

/*
 * 2022. 03. 30
 * STL Class
 * Week 5
 * 
 * STRING 클래스 파일 분리
 */



 // drmemory, makefile
 // 앞으로 사용할 class STRING 작성 시작(RAII)
 // 문제: main()이 문제없이 실행되게 하자
 // 관찰할 수 있도록 special 함수에 출력메시지를 추가한다
 // 객체가 생성될때마다 고유번호를 준다



#include <iostream>
#include <array>
#include <vector>
#include "save.h"

#include "STRING.h"
extern bool printMsg;

int main() {
	std::array<STRING, 3> a{ "2022", "3", "30" };
	

	for (auto x : a) {
		std::cout << x;
	}
	
	save("source.cpp");
}



파일이름: source.cpp
파일크기: 598
2022-03-30 19:05:05 GMT+9

/*
 * 2022. 03. 30
 * STL Class
 * Week 5
 * 
 * STRING 클래스 파일 분리
 */



 // drmemory, makefile
 // 앞으로 사용할 class STRING 작성 시작(RAII)
 // 문제: main()이 문제없이 실행되게 하자
 // 관찰할 수 있도록 special 함수에 출력메시지를 추가한다
 // 객체가 생성될때마다 고유번호를 준다



#include <iostream>
#include <array>
#include <vector>
#include "save.h"

#include "STRING.h"
extern bool printMsg;

int main() {
	printMsg = true;

	std::array<STRING, 3> a{ "2022", "3", "30" };
	

	for (auto x : a) {
		std::cout << x;
	}
	
	save("source.cpp");
}



파일이름: source.cpp
파일크기: 599
2022-03-30 19:06:15 GMT+9

/*
 * 2022. 03. 30
 * STL Class
 * Week 5
 * 
 * STRING 클래스 파일 분리
 */



 // drmemory, makefile
 // 앞으로 사용할 class STRING 작성 시작(RAII)
 // 문제: main()이 문제없이 실행되게 하자
 // 관찰할 수 있도록 special 함수에 출력메시지를 추가한다
 // 객체가 생성될때마다 고유번호를 준다



#include <iostream>
#include <array>
#include <vector>
#include "save.h"

#include "STRING.h"
extern bool printMsg;

int main() {
	printMsg = true;

	std::array<STRING, 3> a{ "2022", "3", "30" };
	

	for (auto& x : a) {
		std::cout << x;
	}
	
	save("source.cpp");
}



파일이름: source.cpp
파일크기: 605
2022-03-30 19:06:49 GMT+9

/*
 * 2022. 03. 30
 * STL Class
 * Week 5
 * 
 * STRING 클래스 파일 분리
 */



 // drmemory, makefile
 // 앞으로 사용할 class STRING 작성 시작(RAII)
 // 문제: main()이 문제없이 실행되게 하자
 // 관찰할 수 있도록 special 함수에 출력메시지를 추가한다
 // 객체가 생성될때마다 고유번호를 준다



#include <iostream>
#include <array>
#include <vector>
#include "save.h"

#include "STRING.h"
extern bool printMsg;

int main() {
	printMsg = true;

	std::array<STRING, 3> a{ "2022", "3", "30" };
	

	for (const auto& x : a) {
		std::cout << x;
	}
	
	save("source.cpp");
}



파일이름: source.cpp
파일크기: 607
2022-03-30 19:07:12 GMT+9

/*
 * 2022. 03. 30
 * STL Class
 * Week 5
 * 
 * STRING 클래스 파일 분리
 */



 // drmemory, makefile
 // 앞으로 사용할 class STRING 작성 시작(RAII)
 // 문제: main()이 문제없이 실행되게 하자
 // 관찰할 수 있도록 special 함수에 출력메시지를 추가한다
 // 객체가 생성될때마다 고유번호를 준다



#include <iostream>
#include <array>
#include <vector>
#include "save.h"

#include "STRING.h"
extern bool printMsg;

int main() {
	printMsg = true;

	std::array<STRING, 3> a{ "2022", "3", "30" };
	

	for (const STRING& x : a) {
		std::cout << x;
	}
	
	save("source.cpp");
}



파일이름: source.cpp
파일크기: 756
2022-03-30 19:10:44 GMT+9

/*
 * 2022. 03. 30
 * STL Class
 * Week 5
 * 
 * STRING 클래스 파일 분리
 */



 // drmemory, makefile
 // 앞으로 사용할 class STRING 작성 시작(RAII)
 // 문제: main()이 문제없이 실행되게 하자
 // 관찰할 수 있도록 special 함수에 출력메시지를 추가한다
 // 객체가 생성될때마다 고유번호를 준다



#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"

#include "STRING.h"
extern bool printMsg;

int main() {
	//printMsg = true;

	std::array<STRING, 3> a{ "2022", "3", "30" };
	
	// 길이 오름차순으로 a를 정렬한 후 출력

	sort(a.begin(), a.end(), [](STRING& a, STRING& b) {
		return a.getNumber() < b.getNumber();
		});

	for (const auto& x : a) {
		std::cout << x;
	}
	
	save("source.cpp");
}

