

파일이름: source.cpp
파일크기: 358
2022-03-23 17:49:17 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sor를 통해 알아본다
 * 
 */

#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

int main() {
	std::ifstream in{ "source.cpp" };
	char c;

	in >> std::noskipws;
	while (in >> c) {
		std::cout << c;
	}

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 427
2022-03-23 17:52:47 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sor를 통해 알아본다
 * 
 */

#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

int main() {
	std::ifstream in{ "source.cpp" };
	char c;

	in >> std::noskipws;
	while (in >> c) {
		if (islower(c)) {
			c = toupper(c);
			// ch to uppercase
		}
		std::cout << c;
	}

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 418
2022-03-23 17:54:40 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sor를 통해 알아본다
 * 
 */

#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

int main() {
	std::ifstream in{ "source.cpp" };
	std::ofstream out{ "source_capital.cpp" };

	char c;

	in >> std::noskipws;
	while (in >> c) {
		c = toupper(c);
		out << c;
	}

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 498
2022-03-23 18:09:08 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sor를 통해 알아본다
 * 
 */

#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

int main() {
	std::ifstream in{ "source.cpp" };
	std::ofstream out{ "source_capital.cpp" };

	std::transform(std::istreambuf_iterator<char>{in}, std::istreambuf_iterator<char>{in}, std::ostreambuf_iterator<char>{std::cout},
		[](char c) { return toupper(c); });

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 498
2022-03-23 18:09:28 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sor를 통해 알아본다
 * 
 */

#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

int main() {
	std::ifstream in{ "source.cpp" };
	std::ofstream out{ "source_capital.cpp" };

	std::transform(std::istreambuf_iterator<char>{in}, std::istreambuf_iterator<char>{in}, std::ostreambuf_iterator<char>{std::cout},
		[](char c) { return toupper(c); });

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 466
2022-03-23 18:10:18 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sor를 통해 알아본다
 * 
 */

#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

int main() {
	std::ifstream in{ "source.cpp" };
	std::ofstream out{ "source_capital.cpp" };

	std::transform(std::istreambuf_iterator<char>{in}, {}, std::ostreambuf_iterator<char>{std::cout},
		[](char c) { return toupper(c); });

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 573
2022-03-23 18:15:50 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sor를 통해 알아본다
 * 
 */

#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

// 문제: "source.cpp"를 읽어서
// 숫자를 *로 바꿔
// 화면에 출력하라

int main() {
	std::ifstream in{ "source.cpp" };
	std::ofstream out{ "source_capital.cpp" };

	std::transform(std::istreambuf_iterator<char>{in}, {}, std::ostreambuf_iterator<char>{std::cout},
		[](char c) {
			if (isdigit(c)) { std::cout << '*'; } return c; });

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 564
2022-03-23 18:16:07 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sor를 통해 알아본다
 * 
 */

#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

// 문제: "source.cpp"를 읽어서
// 숫자를 *로 바꿔
// 화면에 출력하라

int main() {
	std::ifstream in{ "source.cpp" };
	std::ofstream out{ "source_capital.cpp" };

	std::transform(std::istreambuf_iterator<char>{in}, {}, std::ostreambuf_iterator<char>{std::cout},
		[](char c) {
			if (isdigit(c)) { c = '*'; } return c; });

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 709
2022-03-23 18:36:00 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include <array>
#include <algorithm>
#include <random>
#include "save.h"

// 문제: 랜덤 int 100개를 생성
// 오름차순으로 정렬
// 정렬된 결과를 출력

std::random_device rd;
std::default_random_engine dre(rd());


int main() {
	std::uniform_int_distribution<int> uid(std::numeric_limits<int>::min(), std::numeric_limits<int>::max());
	
	std::array<int, 100> numbers;
	numbers.fill(uid(dre));
	
	for (int n : numbers) {
		std::cout << n << '\t';
	}



	save("source.cpp");
}



파일이름: source.cpp
파일크기: 745
2022-03-23 18:40:18 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include <array>
#include <format>
#include <algorithm>
#include <random>
#include "save.h"

// 문제: 랜덤 int 100개를 생성
// 오름차순으로 정렬
// 정렬된 결과를 출력

std::random_device rd;
std::default_random_engine dre(rd());


int main() {
	std::uniform_int_distribution<int> uid(std::numeric_limits<int>::min(), std::numeric_limits<int>::max());
	
	std::array<int, 100> numbers;
	
	for (int& number : numbers) {
		number = uid(dre);
		std::cout << std::format("{:20}", number);
	}

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 744
2022-03-23 18:40:56 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include <array>
#include <format>
#include <algorithm>
#include <random>
#include "save.h"

// 문제: 랜덤 int 100개를 생성
// 오름차순으로 정렬
// 정렬된 결과를 출력

std::random_device rd;
std::default_random_engine dre(rd());


int main() {
	std::uniform_int_distribution<int> uid(std::numeric_limits<int>::min(), std::numeric_limits<int>::max());
	
	std::array<int, 100> numbers;
	
	for (int& number : numbers) {
		number = uid(dre);
		std::cout << std::format("{:5}", number);
	}

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 829
2022-03-23 18:42:04 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include <array>
#include <format>
#include <algorithm>
#include <random>
#include "save.h"

// 문제: 랜덤 int 100개를 생성
// 오름차순으로 정렬
// 정렬된 결과를 출력

std::random_device rd;
std::default_random_engine dre(rd());


int main() {
	std::uniform_int_distribution<int> uid(std::numeric_limits<int>::min(), std::numeric_limits<int>::max());
	
	std::array<int, 100> numbers;
	
	for (int& number : numbers) {
		number = uid(dre);
	}

	std::sort(numbers.begin(), numbers.end());

	for (int number : numbers) {
		std::cout << std::format("{:20}", number);
	}

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 829
2022-03-23 18:42:15 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include <array>
#include <format>
#include <algorithm>
#include <random>
#include "save.h"

// 문제: 랜덤 int 100개를 생성
// 오름차순으로 정렬
// 정렬된 결과를 출력

std::random_device rd;
std::default_random_engine dre(rd());


int main() {
	std::uniform_int_distribution<int> uid(std::numeric_limits<int>::min(), std::numeric_limits<int>::max());
	
	std::array<int, 100> numbers;
	
	for (int& number : numbers) {
		number = uid(dre);
	}

	std::sort(numbers.begin(), numbers.end());

	for (int number : numbers) {
		std::cout << std::format("{:20}", number);
	}

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 778
2022-03-23 18:44:40 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include <array>
#include <format>
#include <algorithm>
#include <random>
#include "save.h"

// 문제: [1, 100] 정수를 생성
// 오름차순으로 정렬
// 정렬된 결과를 출력

std::random_device rd;
std::default_random_engine dre(rd());
std::uniform_int_distribution<int> uid(1, 100);


int main() {
	
	std::array<int, 100> numbers;
	
	for (int& number : numbers) {
		number = uid(dre) % 100 + 1;
	}

	std::sort(numbers.begin(), numbers.end());

	for (int number : numbers) {
		std::cout << std::format("{:4}", number);
	}

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 825
2022-03-23 19:01:12 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include <array>
#include <format>
#include <algorithm>
#include <random>
#include "save.h"

// 문제: [1, 100] 정수를 생성
// 오름차순으로 정렬
// 정렬된 결과를 출력

std::random_device rd;
std::default_random_engine dre(rd());
std::uniform_int_distribution<int> uid(1, 100);


int main() {
	
	std::array<int, 100> numbers;
	
	for (int& number : numbers) {
		number = uid(dre) % 100 + 1;
	}

	std::sort(numbers.begin(), numbers.end(), 
		[](int a, int b) {
			return a > b;
		});

	for (int number : numbers) {
		std::cout << std::format("{:4}", number);
	}

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 844
2022-03-23 19:05:30 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include <array>
#include <format>
#include <algorithm>
#include <random>
#include "save.h"

// 문제: [1, 100] 정수를 생성
// 오름차순으로 정렬
// 정렬된 결과를 출력

std::random_device rd;
std::default_random_engine dre(rd());
std::uniform_int_distribution<int> uid(1, 100);

bool Descending(int a, int b) {
	return a > b;
}


int main() {
	
	std::array<int, 100> numbers;
	
	for (int& number : numbers) {
		number = uid(dre) % 100 + 1;
	}

	std::sort(numbers.begin(), numbers.end(), Descending);

	for (int number : numbers) {
		std::cout << std::format("{:4}", number);
	}

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 494
2022-03-23 19:06:45 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);


// 메모리 마지막 동네 소개
//
//

void f() {
	std::cout << "f" << std::endl;
}

int main() {
	f();
	*f;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 487
2022-03-23 19:06:54 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);


// 메모리 마지막 동네 소개
//
//

void f() {
	std::cout << "f" << std::endl;
}

int main() {
	*f;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 487
2022-03-23 19:07:05 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);


// 메모리 마지막 동네 소개
//
//

void f() {
	std::cout << "f" << std::endl;
}

int main() {
	&f;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 512
2022-03-23 19:08:26 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);


// 메모리 마지막 동네 소개
//
//

void f() {
	std::cout << "f" << std::endl;
}

int main() {
	void(*const ptr)(f);

	*f;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 512
2022-03-23 19:08:42 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);


// 메모리 마지막 동네 소개
//
//

void f() {
	std::cout << "f" << std::endl;
}

int main() {
	void(*const ptr)(f);

	&f;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 516
2022-03-23 19:08:59 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);


// 메모리 마지막 동네 소개
//
//

void f() {
	std::cout << "f" << std::endl;
}

int main() {
	void(*const ptr)() = f;

	ptr;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 517
2022-03-23 19:09:03 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);


// 메모리 마지막 동네 소개
//
//

void f() {
	std::cout << "f" << std::endl;
}

int main() {
	void(*const ptr)() = f;

	*ptr;

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 525
2022-03-23 19:10:21 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);


// 메모리 마지막 동네 소개
//
//

void f() {
	std::cout << "f" << std::endl;
}

int main() {
	void(*const ptr)(void) = f;

	(*ptr)();

	save("source.cpp");
}



파일이름: source.cpp
파일크기: 674
2022-03-23 19:14:39 GMT+9

/*
 * 2022. 03. 23
 * STL Class
 * Week 4
 * 
 * 호출가능타입(Callable type) - sort를 통해 알아본다
 * 
 * 자원을 확보하는 관찰용 클래스 STRING - 컨테이너/반복자/알고리즘
 */

#include <iostream>
#include "save.h"

//std::random_device rd;
//std::default_random_engine dre(rd());
//std::uniform_int_distribution<int> uid(1, 100);


// 메모리 마지막 동네 소개
//
//

void f() {
	std::cout << "f" << std::endl;
}

int main() {
	void(*const ptr)(void) = f;

	(*ptr)();

	std::cout << std::addressof(f) << std::endl;
	std::cout << std::addressof(main) << std::endl;
	std::cout << std::addressof(save) << std::endl;

	save("source.cpp");
}

